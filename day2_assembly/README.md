
## Before tutorial
We have prepared some tools in the conda environment. To use the genome assembly tools in the exercise, you need to run 

```
. /shared/miniconda3/etc/profile.d/conda.sh
 conda activate base
 ```
 if you did not activate conda base.


## 1. Short read assembly

The short-read data is generated by data simulation on the lambda bacteriophage genome. The entire genome sequence was determined by Sanger in 1982, and published [here](https://www.sciencedirect.com/science/article/pii/0022283682905460). In its circular form, the phage genome is 48,502 base pairs in length. 

and the assembly tool used in this tutorial is `velvet`. [Velvet](https://www.ebi.ac.uk/~zerbino/velvet/) is an open-source short-read de novo assembler using de Bruijn graphs, developed by Daniel Zerbino and Ewan Birney. It is very old (last commit was in 2014 in https://github.com/dzerbino/velvet), but it works well so we use this as an example for de novo assembly using short reads.

### 1.1 Preparation of folders and data

1. `mkdir -p ~/project/assembly/short-reads` to prepare a folder the assembly.
2. `cd ~/project/assembly/short-reads` to go to the assembly folder
3. `ln -s /shared/data/lambda_short data` to link data folder

We will use two FASTQ files for the assembly. We can use the `wc` and `head` command described previously to get a general idea on the files. We will see that each file has 16150 reads with read length of 150bp. So the data coverage is approximately 100X.

### 1.2 Running `velvet`
Then we run `velvet`, a short read assembler using the de bruijn graph described in class.

```
velveth lambda_vel 31 -shortPaired -separate -fastq data/art.lambda.cov1001.fq data/art.lambda.cov1002.fq
velvetg lambda_vel
```

There are two main functions in velvet: `velveth` helps to construct the data set (hashes the reads) for `velvetg` and includes information about the meaning of each sequence files. `velvetg` builds the de Bruijn graph from the k-mers obtained by velveth and runs simplification and error correction over the graph. It then extracts the contigs.

The general command syntax is `velveth output_directory hash_length [[-file_format][-read_type] filename]`. Here we used two paired FASTQ files and we use `-separate` argument to tell the program to read 2 separate files for paired reads.

The last line of the results shows statistics on the de Bruijn graph: "Final graph has 63 nodes and n50 of 5561, max 12004, total 49073, using 0/32300 reads".

#### 1.3 Assembly results
The results of the assembly can be found in the files 

`lambda_vel/contigs.fa`: contig file

In this file, we can see over a dozen contigs in this file. The first a few contigs are something similar to below:

```
>NODE_2_length_2656_cov_79.119354
>NODE_3_length_4394_cov_75.604233
>NODE_11_length_5561_cov_81.325119
>NODE_13_length_1039_cov_84.607315
>NODE_20_length_191_cov_84.942406
>NODE_21_length_39_cov_1.000000
>NODE_24_length_31_cov_1.000000
>NODE_25_length_31_cov_1.000000
>NODE_26_length_31_cov_1.000000
>NODE_30_length_31_cov_1.000000
```

So the assembly is quite fragmented. Now we can tweak the parameters a bit and see if we can improve the quality:

```
velvetg lambda_vel -exp_cov 100 -ins_length 500 -min_contig_lgth 100
```

This time, we only need to run `velvetg` again but with different set of parameters. Here we specify the minimum contig length to be 150bp, and specify the expected k-mer coverage of unique regions to be 100X, and the insert length to be 500bp. Note that all coverage values in Velvet are provided in k-mer coverage, i.e. how many times has a k-mer been seen among the reads. The relation between k-mer coverage C_k and standard (nucleotide-wise) coverage C is C_k = C ∗ (L − k + 1)/L where k is your hash length, and L is read length. So the k-mer coverage is 100*(150-31+1)/150=80.

We will see a message at the end of assembly process: "Final graph has 54 nodes and n50 of 48465, max 48465, total 49401, using 32299/32300 reads". There are only one contig that is 48465bp long in the end.


```
>NODE_16_length_48465_cov_78.251312
```

Therefore, the assembly quality is significantly improved with the additional arguments in the assembly program.


## 2. Long read assembly

The long-read data was generated on lambda DNA control on the Oxford Nanopore platform by Dr. Fang Li in our lab, and the data is stored in `/shared/data/lambda_100x/lambda_100x.fastq`. In this tutorial, two tools will be used to conduct long read sequence assembly.

### 2.1 Canu
#### 2.1.1 Preparation of folders and data
First, we create an assembly folder to store results.
```
mkdir -p ~/project/assembly/long-reads-lambda/canu
```
Then enter the directory: `cd ~/project/assembly/long-reads-lambda/canu`

#### 2.1.2 Running `canu`
To do the assembly, run 
```
nohup time canu -p lambda_canu -d lambda_canu genomeSize=50k -nanopore-raw /shared/data/lambda_100x/lambda_100x.fastq gnuplotTested=true useGrid=False minReadLength=500 > canu.nohup.log &
```
It would take several minutes to be done. 
 
#### 2.1.3 Assembly results
The results can be found in `lambda_canu/lambda_canu.contigs.fasta`

### 2.2 wtdbg2
#### 2.2.1 Preparation of folders and data
First, we create an assembly folderto store results.
```
mkdir -p ~/project/assembly/long-reads-lambda/wtdbg2
cd ~/project/assembly/long-reads-lambda/wtdbg2
```

#### 2.2.2 Run `wtdbg2` step-by-step
There are several steps to use `wtdbg2` for genome assembly.

```
/shared/tools/wtdbg2/wtdbg2 -x ont -g 50k -i /shared/data/lambda_100x/lambda_100x.fastq -t 2 -fo lambda_wtdbg2
```
to assemble long reads. 

```
/shared/tools/wtdbg2/wtpoa-cns -t 2 -i lambda_wtdbg2.ctg.lay.gz -fo lambda_wtdbg2.ctg.slf.fa
```
to derive consensus.

#### 2.2.3 Polishing
Additionally, the assembled sequence can be polished using the commands below
```
minimap2 -t 2 -ax map-ont lambda_wtdbg2.ctg.slf.fa /shared/data/lambda_100x/lambda_100x.fastq | samtools sort -@2 >lambda_wtdbg2.ctg.map.srt.bam
samtools view lambda_wtdbg2.ctg.map.srt.bam | /shared/tools/wtdbg2/wtpoa-cns -t 2 -d lambda_wtdbg2.ctg.slf.fa -i - -fo lambda_wtdbg2.ctg.lrp.fa
```

#### 2.2.4 Assembly results
Finally, the result sequence can be found in `lambda_wtdbg2.ctg.slf.fa`, and the polished sequence can be found in `lambda_wtdbg2.ctg.lrp.fa`.


## 3. Evaluation of assembly results

We next evaluate the results of the assembly. For both canu and wtdbg, only one contig is generated from the assembly of 100X data, unlike short-read assembly where hundreds of contigs are generated. The reference genome is ~48kb, so we compare the assembly with the reference genome first to evaluate completeness and accuracy.



## After tutorial

To do other tutorial, you need to run `conda deactivate` to go back to the base environment for other projects. ***If you still have issues to run other projects, please re-login.***




## Before tutorial
We have prepared some tools in the conda environment. To use the genome assembly tools in the exercise, you need to run 

```
. /shared/miniconda3/etc/profile.d/conda.sh
 conda activate base
 ```
 if you did not activate conda base.


## 1. Short read assembly

The short-read data is generated by data simulation on the lambda bacteriophage genome. The entire genome sequence was determined by Sanger in 1982, and published [here](https://www.sciencedirect.com/science/article/pii/0022283682905460). In its circular form, the phage genome is 48,502 base pairs in length. 

The assembly tool used in this tutorial is `velvet`. [Velvet](https://www.ebi.ac.uk/~zerbino/velvet/) is an open-source short-read de novo assembler using de Bruijn graphs, developed by Daniel Zerbino and Ewan Birney. It is very old (last commit was in 2014 in https://github.com/dzerbino/velvet), but it works well so we use this as an example for de novo assembly using short reads.

### 1.1 Preparation of folders and data

1. `mkdir -p ~/project/assembly/short-reads` to prepare a folder the assembly.
2. `cd ~/project/assembly/short-reads` to go to the assembly folder
3. `ln -s /shared/data/lambda_short data` to link data folder

We will use two FASTQ files for the assembly. We can use the `wc` and `head` command described previously to get a general idea on the files. We will see that each file has 16150 reads with read length of 150bp. So the data coverage is approximately 100X.

Another easy way to check the length distribution and total base pairs in a FASTQ file is shown below:

```
awk 'NR%4 == 2 {lengths[length($0)]++ ; counter++; totallen+=length($0)} END {for (l in lengths) {print l, lengths[l]}; print "total reads: " counter; print "total length: " totallen}' data/art.lambda.cov1001.fq
```

The logic of the `awk` command is this: for every second line in 4 lines (the sequence line), measure the length of the sequence and record the information in count and totallen. When all lines are read, loop over the array to print its content. Finally, print out the total number of reads and total length of reads.

It is not that important for this particular dataset, because all reads have the same length, but it will be useful in some scenarios (for example, after adapter trimming of FASTQ files, or for long-read sequencing). The results are below, showing that there are 16150 reads with 150bp, totalling 2.4 million bases.

```
150 16150
total reads: 16150
total length: 2422500
```


### 1.2 Running `velvet`
Then we run `velvet`, a short read assembler using the de bruijn graph described in class.

```
velveth lambda_vel 31 -shortPaired -separate -fastq data/art.lambda.cov1001.fq data/art.lambda.cov1002.fq
velvetg lambda_vel
```

There are two main functions in velvet: `velveth` helps to construct the data set (hashes the reads) for `velvetg` and includes information about the meaning of each sequence files. `velvetg` builds the de Bruijn graph from the k-mers obtained by velveth and runs simplification and error correction over the graph. It then extracts the contigs.

The general command syntax is `velveth output_directory hash_length [[-file_format][-read_type] filename]`. Here we used two paired FASTQ files and we use `-separate` argument to tell the program to read 2 separate files for paired reads.

The last line of the results shows statistics on the de Bruijn graph: "Final graph has 63 nodes and n50 of 5561, max 12004, total 49073, using 0/32300 reads".

#### 1.3 Assembly results
The results of the assembly can be found in the files 

`lambda_vel/contigs.fa`: contig file

In this file, we can see over a dozen contigs in this file. Using `grep '>' lambda_vel/contigs.fa | head`, the first a few contigs are something similar to below:

```
>NODE_2_length_2656_cov_79.119354
>NODE_3_length_4394_cov_75.604233
>NODE_11_length_5561_cov_81.325119
>NODE_13_length_1039_cov_84.607315
>NODE_20_length_191_cov_84.942406
>NODE_21_length_39_cov_1.000000
>NODE_24_length_31_cov_1.000000
>NODE_25_length_31_cov_1.000000
>NODE_26_length_31_cov_1.000000
>NODE_30_length_31_cov_1.000000
```

So the assembly is quite fragmented. Now we can tweak the parameters a bit and see if we can improve the quality:

```
velvetg lambda_vel -exp_cov 80 -ins_length 500 -min_contig_lgth 150
```

This time, we only need to run `velvetg` again but with different set of parameters. Here we specify the minimum contig length to be 150bp, and specify the expected k-mer coverage of unique regions to be 100X, and the insert length to be 500bp. Note that all coverage values in Velvet are provided in k-mer coverage, i.e. how many times has a k-mer been seen among the reads. The relation between k-mer coverage C_k and standard (nucleotide-wise) coverage C is C_k = C ∗ (L − k + 1)/L where k is your hash length, and L is read length. So the k-mer coverage is 100*(150-31+1)/150=80.

We will see a message at the end of assembly process: "Final graph has 54 nodes and n50 of 48465, max 48465, total 49401, using 32299/32300 reads". There are only one contig that is 48465bp long in the end.


```
>NODE_16_length_48465_cov_78.251312
```

Therefore, the assembly quality is significantly improved with the additional arguments in the assembly program.


## 2. Long read assembly

The long-read data was generated on lambda DNA control on the Oxford Nanopore platform by Dr. Fang Li in our lab, and the data is stored in `/shared/data/lambda_100x/lambda_100x.fastq`. Using the awk command described above, we can get a basic idea about the data set below. Again it is approximately 100X coverage.

```
total reads: 1591
total length: 4786525
```
In this tutorial, two tools will be used to conduct long read sequence assembly, including canu and wtdbg.

### 2.1 Canu
#### 2.1.1 Preparation of folders and data
First, we create an assembly folder to store results.
```
mkdir -p ~/project/assembly/long-reads-lambda/canu
```
Then enter the directory: `cd ~/project/assembly/long-reads-lambda/canu`

#### 2.1.2 Running `canu`
To do the assembly, run 
```
canu -p lambda_canu -d lambda_canu genomeSize=50k -nanopore-raw /shared/data/lambda_100x/lambda_100x.fastq gnuplotTested=true useGrid=False minReadLength=500
```
It would take several minutes to be done. 

#### 2.1.3 Assembly results
The results can be found in `lambda_canu/lambda_canu.contigs.fasta`

We can check how many contigs are generated:
```
grep '>' lambda_canu/lambda_canu.contigs.fasta
```

The results show that one contig with 48160bp is assembled.
```
>tig00000001 len=48160 reads=169 covStat=29.03 gappedBases=no class=contig suggestRepeat=no suggestCircular=no
```

### 2.2 wtdbg2
#### 2.2.1 Preparation of folders and data
First, we create an assembly folderto store results.
```
mkdir -p ~/project/assembly/long-reads-lambda/wtdbg2
cd ~/project/assembly/long-reads-lambda/wtdbg2
```

#### 2.2.2 Run `wtdbg2` step-by-step
There are several steps to use `wtdbg2` for genome assembly.

```
/shared/tools/wtdbg2/wtdbg2 -x ont -g 50k -i /shared/data/lambda_100x/lambda_100x.fastq -t 2 -fo lambda_wtdbg2
```
to assemble long reads. 

```
/shared/tools/wtdbg2/wtpoa-cns -t 2 -i lambda_wtdbg2.ctg.lay.gz -fo lambda_wtdbg2.ctg.slf.fa
```
to derive consensus.

#### 2.2.3 Polishing
Additionally, the assembled sequence can be polished using the commands below
```
minimap2 -t 2 -ax map-ont lambda_wtdbg2.ctg.slf.fa /shared/data/lambda_100x/lambda_100x.fastq | samtools sort -@2 >lambda_wtdbg2.ctg.map.srt.bam
samtools view lambda_wtdbg2.ctg.map.srt.bam | /shared/tools/wtdbg2/wtpoa-cns -t 2 -d lambda_wtdbg2.ctg.slf.fa -i - -fo lambda_wtdbg2.ctg.lrp.fa
```

#### 2.2.4 Assembly results
Finally, the result sequence can be found in `lambda_wtdbg2.ctg.slf.fa`, and the polished sequence can be found in `lambda_wtdbg2.ctg.lrp.fa`.


## 3. Evaluation of assembly results

We next evaluate the results of the assembly. For both canu and wtdbg, only one contig is generated from the assembly of 100X data, unlike short-read assembly where hundreds of contigs are generated. The reference genome is ~48kb, so we compare the assembly with the reference genome first to evaluate completeness and accuracy.



## After tutorial

To do other tutorial, you need to run `conda deactivate` to go back to the base environment for other projects. ***If you still have issues to run other projects, please re-login.***


